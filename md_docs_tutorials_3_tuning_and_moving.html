<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="LemLib" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="An easy to use and feature-rich PROS template for the Vex V5" />
<meta property="og:url" content="https://lemlib.github.io/LemLib/html/index.html" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="LemLib" />
<meta name="twitter:description" content="An easy to use and feature-rich PROS template for the Vex V5" />
<!-- END twitter metadata -->
<title>LemLib: 03 - Tuning and Moving</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/LemLib/LemLib" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LemLib
   &#160;<span id="projectnumber">0.4.5</span>
   </div>
   <div id="projectbrief">An easy to use and feature-rich PROS template</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_tutorials_3_tuning_and_moving.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03 - Tuning and Moving </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md18"></a>
Introduction</h1>
<p >Welcome to the third LemLib tutorial! In this tutorial, we will be learning how to tune the PIDs, move the robot, and use odometry.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Odometry</h1>
<p >As mentioned in the previous tutorial, LemLib uses odometry to track the position of the robot. However, we need to calibrate it at the start of each match. To do this, we need to call the <code>chassis.calibrate()</code> function in <code>initialize()</code> Below is an example of how to do this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> initialize() {</div>
<div class="line">    chassis.calibrate();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that the chassis should be stationary when you call this function. It will take 3 seconds to calibrate, so don't be alarmed if it doesn't seem to be doing anything.</p>
<p >Pretty simple, right? Now, we can use the <code>chassis.getPose()</code> function to get the current position of the robot. It returns a <code><a class="el" href="classlemlib_1_1Pose.html">lemlib::Pose</a></code> object, which contains the x, y, and heading. The code below uses the <code>chassis.getPose()</code> function to print the current position of the robot to the brain screen: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> screen() {</div>
<div class="line">    <span class="comment">// loop forever</span></div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <a class="code hl_class" href="classlemlib_1_1Pose.html">lemlib::Pose</a> pose = chassis.getPose(); <span class="comment">// get the current position of the robot</span></div>
<div class="line">        pros::lcd::print(0, <span class="stringliteral">&quot;x: %f&quot;</span>, pose.x); <span class="comment">// print the x position</span></div>
<div class="line">        pros::lcd::print(1, <span class="stringliteral">&quot;y: %f&quot;</span>, pose.y); <span class="comment">// print the y position</span></div>
<div class="line">        pros::lcd::print(2, <span class="stringliteral">&quot;heading: %f&quot;</span>, pose.theta); <span class="comment">// print the heading</span></div>
<div class="line">        pros::delay(10);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> initialize() {</div>
<div class="line">    chassis.calibrate(); <span class="comment">// calibrate the chassis</span></div>
<div class="line">    pros::Task screenTask(screen); <span class="comment">// create a task to print the position to the screen</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasslemlib_1_1Pose_html"><div class="ttname"><a href="classlemlib_1_1Pose.html">lemlib::Pose</a></div><div class="ttdef"><b>Definition:</b> pose.hpp:14</div></div>
</div><!-- fragment --><p >We can also set the position of the robot using the <code>chassis.setPose()</code> function. Below is an example of how to do this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> initialize() {</div>
<div class="line">    chassis.calibrate(); <span class="comment">// calibrate the chassis</span></div>
<div class="line">    chassis.setPose(0, 0, 0); <span class="comment">// X: 0, Y: 0, Heading: 0</span></div>
<div class="line">    chassis.setPose(5.2, 10.333, 87); <span class="comment">// X: 5.2, Y: 10.333, Heading: 87</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
Moving with turnTo and moveTo</h1>
<p >LemLib has 3 functions for moving the to. We will be covering the first 2 in this tutorial, and the third in the next tutorial.</p>
<p >The first function is <code><a class="el" href="classlemlib_1_1Chassis.html#ab6bafad2ac9224ef669eb3a8caec7085" title="Turn the chassis so it is facing the target point.">lemlib::Chassis::turnTo</a></code>. This function turns the robot so that it is facing the specified (x, y) point. It takes between 3 and 5 arguments. It uses the PID gains specified in the lateralController struct. Below is an example of how to use it: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="main_8h.html#a2df3d06bc5bced154da27fce393f991f">autonomous</a>() {</div>
<div class="line">    chassis.turnTo(53, 53, 1000); <span class="comment">// turn to the point (53, 53) with a timeout of 1000 ms</span></div>
<div class="line">    chassis.turnTo(-20, 32, 1500, <span class="keyword">true</span>); <span class="comment">// turn to the point (-20, 32) with the back of the robot facing the point, and a timeout of 1500 ms</span></div>
<div class="line">    chassis.turnTo(10, 0, 1000, <span class="keyword">false</span>, 50); <span class="comment">// turn to the point (10, 0) with a timeout of 1000 ms, and a maximum speed of 50</span></div>
<div class="line">}</div>
<div class="ttc" id="amain_8h_html_a2df3d06bc5bced154da27fce393f991f"><div class="ttname"><a href="main_8h.html#a2df3d06bc5bced154da27fce393f991f">autonomous</a></div><div class="ttdeci">void autonomous(void)</div></div>
</div><!-- fragment --><p >As you can see, using this function is very easy. The first 2 parameters are the X and Y location the robot should be facing. The third parameter is the timeout, which is the maximum time the robot can spend turning before giving up. The fourth parameter is whether the back of the robot should face the point (true) or the front of the robot should face the point (false). It defaults to false if not specified. The fifth parameter is the maximum speed the robot can turn at. If you don't specify a value for this parameter, the robot will turn at full speed.</p>
<p >The second function is <code><a class="el" href="classlemlib_1_1Chassis.html#a00edce017c843ba5080f6d7494dc52bd" title="Move the chassis towards the target point.">lemlib::Chassis::moveTo</a></code>. This function moves the robot to the specified (x, y) point. It takes 3 or 4 arguments. It uses the PID gains specified in the lateralController and angularController struct. Below is an example of how to use it: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="main_8h.html#a2df3d06bc5bced154da27fce393f991f">autonomous</a>() {</div>
<div class="line">    chassis.moveTo(53, 53, 1000); <span class="comment">// move to the point (53, 53) with a timeout of 1000 ms</span></div>
<div class="line">    chassis.moveTo(10, 0, 1000, 50); <span class="comment">// move to the point (10, 0) with a timeout of 1000 ms, and a maximum speed of 50</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >This function is very similar to the <code>chassis.turnTo()</code> function. The first 2 parameters are the X and Y location the robot should move towards. The third parameter is the timeout, which is the maximum time the robot can spend turning before giving up. The fourth parameter is the maximum speed the robot can move at. If you don't specify a value for this parameter, the robot will move at full speed.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Tuning the PIDs</h1>
<p >Now that we know how to move the robot, we can start tuning the PIDs. Let's start with the lateral PIDs.</p>
<p >The lateral PID is just a simple PD controller, with some minor optimizations. When we tune the lateral PD, we want the kP as high as possible with minimal oscillation. But how do we change these gains? The answer is the <code>lateralController</code> struct we created in the previous tutorial. Here is a reminder of what it looks like: </p><div class="fragment"><div class="line"><span class="comment">// forward/backward PID</span></div>
<div class="line"><a class="code hl_struct" href="structlemlib_1_1ChassisController__t.html">lemlib::ChassisController_t</a> lateralController {</div>
<div class="line">    10, <span class="comment">// kP</span></div>
<div class="line">    30, <span class="comment">// kD</span></div>
<div class="line">    1, <span class="comment">// smallErrorRange</span></div>
<div class="line">    100, <span class="comment">// smallErrorTimeout</span></div>
<div class="line">    3, <span class="comment">// largeErrorRange</span></div>
<div class="line">    500 <span class="comment">// largeErrorTimeout</span></div>
<div class="line">};</div>
<div class="ttc" id="astructlemlib_1_1ChassisController__t_html"><div class="ttname"><a href="structlemlib_1_1ChassisController__t.html">lemlib::ChassisController_t</a></div><div class="ttdoc">Struct containing constants for a chassis controller.</div><div class="ttdef"><b>Definition:</b> chassis.hpp:55</div></div>
</div><!-- fragment --><p >The first 2 parameters are the kP and kD gains. These are the ones we will be focusing on for now. When we tune them, we want kP as high as possible with minimal oscillation (the robot moving backwards/forwards repeatedly at the end). Here is the algorithm we will be using to tune these gains:</p>
<ol type="1">
<li>Move the robot 10 inches forward using the <code>chassis.moveTo()</code> function</li>
<li>increase kP until the robot starts oscillating</li>
<li>increase kD until the oscillation stops</li>
<li>record kP and kD values</li>
<li>repeat steps 2-4 until you can't stop the oscillation. At this point, use the last kP and kD values you recorded.</li>
</ol>
<p >After this, you need to tune the slew rate. This controls the maximum acceleration of the chassis in order to prevent tipping. To tune it, simply increase it until the robot starts tipping too much. Higher values make the robot accelerate faster, and slower values make the robot accelerate slower.</p>
<p ><br  />
</p>
<p >The process for the angular PID is very similar. Here is a reminder of what the angular PID looks like: </p><div class="fragment"><div class="line"><span class="comment">// turn PID</span></div>
<div class="line"><a class="code hl_struct" href="structlemlib_1_1ChassisController__t.html">lemlib::ChassisController_t</a> angularController {</div>
<div class="line">    2, <span class="comment">// kP</span></div>
<div class="line">    10, <span class="comment">// kD</span></div>
<div class="line">    1, <span class="comment">// smallErrorRange</span></div>
<div class="line">    100, <span class="comment">// smallErrorTimeout</span></div>
<div class="line">    3, <span class="comment">// largeErrorRange</span></div>
<div class="line">    500 <span class="comment">// largeErrorTimeout</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >Here is the algorithm we will be using to tune these gains:</p>
<ol type="1">
<li>Turn the robot to face (30, 0) using the <code>chassis.turnTo()</code> function</li>
<li>increase kP until the robot starts oscillating</li>
<li>increase kD until the oscillation stops</li>
<li>record kP and kD values</li>
<li>repeat steps 2-4 until you can't stop the oscillation. At this point, use the last kP and kD values you recorded.</li>
</ol>
<h1><a class="anchor" id="autotoc_md22"></a>
Optional - Tuning Timeouts</h1>
<p >You may have noticed that there are 4 more values in the angularController and lateralController structs. These are values for the timeouts. Here is how they work:</p>
<ul>
<li><code>smallErrorRange</code> is the range of error that is considered "small". If the error is within this range for <code>smallErrorTimeout</code> milliseconds, the robot will proceed to the next movement</li>
<li><code>largeErrorRange</code> is the range of error that is considered "large". If the error is within this range for <code>largeErrorTimeout</code> milliseconds, the robot will proceed to the next movement</li>
</ul>
<p >The units for error in the <code>chassis.moveTo()</code> function are inches, and degrees for the <code>chassis.turnTo()</code> function. The units for time are milliseconds.</p>
<p >Advanced users may wish to alter these values to decrease the time it takes to execute the next command. However, the default values should be fine for most users.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Using the Path Generator for Coordinates</h1>
<p >Another project we have been developing is the <a href="https://lemlib.github.io/Path-Gen/">Path Generator</a>. This web app allows you to create a path for the robot to follow using pure pursuit, which will be covered in the next tutorial. For now, we will be using it to view coordinates on the field.</p>
<p >When hovering your mouse over a location on the field, its coordinates will be displayed in the bottom left corner. You can then manually input these coordinates into the <code>chassis.moveTo()</code> and <code>chassis.turnTo()</code> functions. You can also view the starting position of the robot by simply hovering your mouse over where it would start. You can set the position of the robot by using the <code>chassis.setPose()</code> function, as documented in <a class="el" href="md_docs_tutorials_2_setting_up_the_chassis.html">tutorial 2</a>. Below is an image of the Path Generator:</p>
<p ><img src="./assets/3_tuning_and_moving/path_generator.png" alt="" class="inline"/></p>
<p >Note that the origin of the field is in the middle, and the field coordinates are measured in inches. <b>0 degrees is facing up, and increases clockwise</b>.</p>
<p >Thats it! You now know how to move the robot around the field using the <code>chassis.turnTo()</code> and <code>chassis.moveTo()</code> functions. In the next tutorial, we will be covering how to use the Path Generator to create a path for the robot to follow.</p>
<p ><a class="el" href="md_docs_tutorials_2_setting_up_the_chassis.html">Previous Tutorial</a> <br  />
 <a class="el" href="md_docs_tutorials_4_pure_pursuit.html">Next Tutorial</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by Doxygen v1.9.5 </li>
  </ul>
</div>
</body>
</html>
